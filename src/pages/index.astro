---
import { Image } from "astro:assets";
import "../styles/global.css";
---
<!doctype html>
<html lang="es">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Oriol Giner Díaz</title>
		<style>
			body {
				margin: 0;
				height: 600vh; /* Aumentado de 300vh a 500vh para permitir más scroll */
			}
			#container {
				width: 100vw;
				height: 100vh;
				position: fixed;
				top: 0;
				left: 0;
				z-index: 0;
			}
			canvas {
				width: 100%;
				height: 100%;
			}
			/* Space to drive fake scroll */
			#scroll-space {
				height: 120vh;
			}
			/* Section that appears after the camera animation */
			#info-section {
				min-height: 100vh;
				display: flex;
				justify-content: center;
				align-items: center;
				flex-direction: column;
				gap: 2rem;
				position: relative;
				z-index: 10;
			}
			.card {
				width: 300px;
				padding: 1.5rem;
				border-radius: 8px;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
				background: #f8f8f8;
			}
			.ocean-text {
				position: absolute;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);
				font-size: clamp(1.5rem, 4vw, 2.5rem);
				font-weight: 700;
				max-width: 800px;
				text-align: center;
				color: #ffffff;
				opacity: 0;
				text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8), 0 0 30px rgba(0, 0, 0, 0.6);
				padding: 1.5rem;
				width: 90%;
				background-color: rgba(0, 0, 0, 0.25);
				backdrop-filter: blur(4px);
				border-radius: 12px;
				box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
				border: 1px solid rgba(255, 255, 255, 0.1);
			}
			.text-container {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100vh;
				z-index: 5;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				pointer-events: none;
			}
			/* Efecto viñeta tipo catalejo */
			.spyglass-container {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100vh;
				z-index: 6;
				display: flex;
				align-items: center;
				justify-content: center;
				pointer-events: none;
				opacity: 0;
			}
			.spyglass-outer {
				position: absolute;
				width: 100%;
				height: 100%;
				background: radial-gradient(
					circle at center,
					transparent 0%,
					transparent 20%,
					rgba(0, 0, 0, 0.8) 20.5%,
					rgba(0, 0, 0, 0.95) 30%,
					rgba(0, 0, 0, 1) 100%
				);
			}
			.spyglass-inner {
				position: absolute;
				width: 40vmin;
				height: 40vmin;
				border-radius: 50%;
				border: 12px solid #403020;
				box-shadow: 
					inset 0 0 20px rgba(0, 0, 0, 0.8),
					0 0 0 4px #302010,
					0 0 20px rgba(0, 0, 0, 0.7);
				overflow: hidden;
				transform: scale(0);
				opacity: 0;
				transition: all 0.3s ease;
			}
			.spyglass-inner.active {
				box-shadow: 
					inset 0 0 20px rgba(0, 0, 0, 0.8),
					0 0 0 4px #302010,
					0 0 30px 10px rgba(255, 230, 180, 0.5);
			}
			.spyglass-lines {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				pointer-events: none;
			}
			.spyglass-line {
				position: absolute;
				background: rgba(0, 0, 0, 0.1);
				pointer-events: none;
			}
			.spyglass-horizontal {
				width: 100%;
				height: 2px;
				top: 50%;
				transform: translateY(-50%);
			}
			.spyglass-vertical {
				height: 100%;
				width: 2px;
				left: 50%;
				transform: translateX(-50%);
			}
			.spyglass-reflection {
				position: absolute;
				width: 150%;
				height: 50%;
				top: -25%;
				left: -25%;
				background: linear-gradient(to bottom, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0) 100%);
				transform: rotate(-45deg);
				pointer-events: none;
				border-radius: 100%;
			}
			.spyglass-crosshair {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				width: 10px;
				height: 10px;
				border-radius: 50%;
				border: 1px solid rgba(255, 140, 0, 0.5);
				box-shadow: 0 0 10px rgba(255, 200, 0, 0.5);
				opacity: 0;
				transition: opacity 1s ease;
			}
			.spyglass-inner.active .spyglass-crosshair {
				opacity: 1;
			}
		</style>
	</head>
	<body class="bg-black">
		<div id="container"></div>

		<!-- Texto introductorio -->
		<div class="intro-text fixed inset-0 flex flex-col items-center justify-center z-20 text-center pointer-events-none select-none">
			<h1 class="text-5xl md:text-6xl font-extrabold text-white drop-shadow-lg mb-4">Soy Oriol Giner</h1>
			<p class="text-xl md:text-2xl font-semibold text-white/90 drop-shadow mb-2 max-w-2xl">
				Un desarrollador de software versatil.
				<br>
				En el vasto océano de la tecnología, guío tus ideas hacia puertos seguros con experiencia y visión.</p>
		</div>

		<!-- Indicador de scroll -->
		<div class="scroll-indicator fixed bottom-10 left-1/2 -translate-x-1/2 z-20 flex flex-col items-center pointer-events-none select-none">
			<div class="animate-bounce">
				<svg class="w-10 h-10 text-white drop-shadow-lg" fill="none" stroke="currentColor" stroke-width="4" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
				</svg>
			</div>
		</div>

		<!-- Textos secuenciales sobre el océano -->
		<div class="text-container">
			<p class="ocean-text ocean-text-1">Muchas veces, en las inmensidades del océano es fácil perderse.</p>
			<p class="ocean-text ocean-text-2">Explora mi trabajo y empecemos a navegar juntos.</p>
		</div>

		<!-- Efecto catalejo -->
		<div class="spyglass-container">
			<div class="spyglass-outer"></div>
			<div class="spyglass-inner">
				<div class="spyglass-lines">
					<div class="spyglass-line spyglass-horizontal"></div>
					<div class="spyglass-line spyglass-vertical"></div>
				</div>
				<div class="spyglass-reflection"></div>
				<div class="spyglass-crosshair"></div>
			</div>
		</div>

		<script>
			import { gsap } from "gsap";
			import { ScrollTrigger } from "gsap/ScrollTrigger";
			gsap.registerPlugin(ScrollTrigger);
			import * as THREE from "three";
			import { Water } from "three/addons/objects/Water.js";
			import { Sky } from "three/addons/objects/Sky.js";
			import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
			var container;
			var camera, scene, renderer;
			var water, sun;
			var cloudMeshes = [];
			var cloudConfigs = [];
			init();

			function init() {
				container = document.getElementById("container");

				// Renderizador
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 0.5;
				container.appendChild(renderer.domElement);

				// Escena
				scene = new THREE.Scene();

				// Cámara
				camera = new THREE.PerspectiveCamera(
					55,
					window.innerWidth / window.innerHeight,
					1,
					20000,
				);
				camera.position.set(0, 100, 0); // Vista desde arriba
				camera.lookAt(0, 0, 0);

				// Sol
				sun = new THREE.Vector3();

				// Agua
				const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
				water = new Water(waterGeometry, {
					textureWidth: 512,
					textureHeight: 512,
					waterNormals: new THREE.TextureLoader().load(
						"/waternormals.jpg",
						function (texture) {
							texture.wrapS = texture.wrapT =
								THREE.RepeatWrapping;
						},
					),
					sunDirection: new THREE.Vector3(),
					sunColor: 0xffffff,
					waterColor: 0x001e0f,
					distortionScale: 3.7,
					fog: scene.fog !== undefined,
				});
				water.rotation.x = -Math.PI / 2;
				scene.add(water);

				// Cielo
				const sky = new Sky();
				sky.scale.setScalar(10000);
				scene.add(sky);

				const skyUniforms = sky.material.uniforms;
				skyUniforms["turbidity"].value = 15; // Más partículas en el aire para amanecer
				skyUniforms["rayleigh"].value = 3;  // Azul intenso
				skyUniforms["mieCoefficient"].value = 0.02; // Más dispersión
				skyUniforms["mieDirectionalG"].value = 0.8; // Luz más direccional

				// Configuración del sol para amanecer
				const parameters = {
					elevation: 5, // Sol bajo, cerca del horizonte
					azimuth: 180, // Este
				};

				const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);
				const theta = THREE.MathUtils.degToRad(parameters.azimuth);
				sun.setFromSphericalCoords(1, phi, theta);
				sky.material.uniforms["sunPosition"].value.copy(sun);
				water.material.uniforms["sunDirection"].value.copy(sun).normalize();

				// Generador de entorno
				const pmremGenerator = new THREE.PMREMGenerator(renderer);
				const sceneEnv = new THREE.Scene();
				sceneEnv.add(sky);
				const renderTarget = pmremGenerator.fromScene(sceneEnv);
				scene.add(sky);
				scene.environment = renderTarget.texture;

				// --- NUBES ---
				const cloudTexture1 = new THREE.TextureLoader().load("/clouds/cloud1.png");
				const cloudTexture2 = new THREE.TextureLoader().load("/clouds/cloud2.png");
				const cloudTexture3 = new THREE.TextureLoader().load("/clouds/cloud3.png");

				const cloudMaterial1 = new THREE.MeshBasicMaterial({
					map: cloudTexture1,
					transparent: true,
					depthWrite: false,
					opacity: 0.7,
				});
				const cloudMaterial2 = new THREE.MeshBasicMaterial({
					map: cloudTexture2,
					transparent: true,
					depthWrite: false,
					opacity: 0.7,
				});
				const cloudMaterial3 = new THREE.MeshBasicMaterial({
					map: cloudTexture3,
					transparent: true,
					depthWrite: false,
					opacity: 0.7,
				});

				// Crear varias nubes con posiciones y tamaños variados
				cloudConfigs = [
					{ x: -200, y: 70, z: -400, scale: 180, mat: cloudMaterial1 },
					{ x: 300, y: 110, z: -350, scale: 150, mat: cloudMaterial2 },
					{ x: 0, y: 190, z: -500, scale: 220, mat: cloudMaterial3 },
					{ x: -350, y: 100, z: -300, scale: 120, mat: cloudMaterial2 },
				];
				cloudConfigs.forEach(cfg => {
					const geometry = new THREE.PlaneGeometry(cfg.scale, cfg.scale * 0.5);
					const mesh = new THREE.Mesh(geometry, cfg.mat);
					mesh.position.set(cfg.x, cfg.y, cfg.z);
					mesh.rotation.x = 0; // Sin inclinación
					scene.add(mesh);
					cloudMeshes.push(mesh);
				});

				// FARO 3D (GLB)
				const gltfLoader = new GLTFLoader();
				gltfLoader.load('/lighthouse.glb', function(gltf) {
					const lighthouse = gltf.scene;
					lighthouse.position.set(0, -20, -9000); // Centrado, horizonte
					lighthouse.scale.set(3, 3, 3); // Ajusta el tamaño según sea necesario
					lighthouse.traverse(function(child) {
						if (child.isMesh) {
							child.castShadow = true;
							child.receiveShadow = true;
						}
					});
					scene.add(lighthouse);
				});

				// Evento de cambio de tamaño
				window.addEventListener("resize", onWindowResize);

				// Iniciar animación
				animate();
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				requestAnimationFrame(animate);
				render();
			}

			function render() {
				const time = performance.now() * 0.001;
				water.material.uniforms["time"].value += 1.0 / 60.0;

				// Movimiento horizontal lento de las nubes
				cloudMeshes.forEach((mesh, i) => {
					const baseX = cloudConfigs[i].x;
					const speed = 5 + i * 2; // Velocidad diferente para cada nube
					mesh.position.x = baseX + Math.sin(time / speed + i) * 40; // Oscilación suave
				});

				renderer.render(scene, camera);
			}

			// -------- Scroll-driven camera animation --------
			window.addEventListener("load", () => {
				// Referencias a elementos DOM
				const scrollSpace = document.getElementById("scroll-space");
				const introText = document.querySelector(".intro-text") as HTMLElement;
				const oceanTexts = document.querySelectorAll(".ocean-text");
				const scrollIndicator = document.querySelector(".scroll-indicator") as HTMLElement;
				const textContainer = document.querySelector(".text-container") as HTMLElement;
				const oceanText1 = document.querySelector(".ocean-text-1") as HTMLElement;
				const oceanText2 = document.querySelector(".ocean-text-2") as HTMLElement;
				const spyglassContainer = document.querySelector(".spyglass-container") as HTMLElement;
				const spyglassInner = document.querySelector(".spyglass-inner") as HTMLElement;
				
				// Calcular puntos de referencia para el scroll
				const totalScrollHeight = document.body.scrollHeight - window.innerHeight;
				const cameraAnimationEnd = window.innerHeight * 1.2; // Altura del scroll-space
				const text1Start = cameraAnimationEnd;
				const text1End = cameraAnimationEnd + window.innerHeight * 1.2; // Aumentado para más duración
				const text2Start = text1End - window.innerHeight * 0.3; // Superposición para transición suave
				const text2End = text2Start + window.innerHeight * 2; // Aumentado significativamente para más duración
				const spyglassStart = text2End + window.innerHeight * 0.2; // El catalejo comienza más tarde para evitar solaparse con el texto
				const spyglassEnd = totalScrollHeight; // Hasta el final del scroll

				// Variables para el catalejo - definidas dentro del scope de load
				let catalejoActivo = false;
				let fov = { value: 55 }; // FOV inicial
				let initialZoom = { value: 0 }; // Zoom inicial
				let lastScrollPosition = 0; // Para detectar dirección del scroll
				let animacionIniciada = false; // Control para evitar iniciar la animación múltiples veces

				// Animación del texto introductorio con GSAP
				if (introText && scrollIndicator) {
					const timeline = gsap.timeline();
					timeline.to(introText, {
						opacity: 1,
						duration: 1,
						ease: "power2.out",
						delay: 0.5
					});
					timeline.from(introText.querySelector("h1"), {
						y: 50,
						opacity: 0,
						duration: 0.8,
						ease: "back.out"
					}, "-=0.5");
					timeline.from(introText.querySelector("p"), {
						y: 30,
						opacity: 0,
						duration: 0.8,
						ease: "power2.out"
					}, "-=0.3");
					timeline.to(scrollIndicator, {
						opacity: 1,
						duration: 0.8,
						ease: "power2.out"
					}, "-=0.2");
				}

				// Función para iniciar la animación del catalejo de forma automática
				function iniciarAnimacionCatalejo() {
					// Mostrar el catalejo con una animación de escala
					if (spyglassInner) {
						gsap.fromTo(spyglassInner, 
							{ transform: "scale(0)", opacity: 0 },
							{ 
								transform: "scale(1)", 
								opacity: 1, 
								duration: 0.5, 
								ease: "back.out",
								onComplete: () => {
									// Añadir clase para efecto de activación
									spyglassInner.classList.add("active");
								}
							}
						);
					}
					
					// Secuencia de animación completa con timeline
					const timeline = gsap.timeline({
						onStart: () => {
							catalejoActivo = true;
						}
					});
					
					// Zoom continuo y fluido en una sola fase
					timeline.to(camera.position, {
						y: 5,
						z: 150,
						duration: 3,
						ease: "power2.inOut",
					}, 0);

					timeline.to(fov, {
						value: 5,
						duration: 3,
						ease: "power2.inOut",
						onUpdate: () => {
							camera.fov = fov.value;
							camera.updateProjectionMatrix();
							// Mantener el punto de mira en el faro durante todo el zoom
							camera.lookAt(0, 60, -9000);
						}
					}, 0);
				}
				
				// Función para resetear la animación del catalejo
				function resetearAnimacionCatalejo() {
					// Detener todas las animaciones GSAP activas
					gsap.killTweensOf(camera.position);
					gsap.killTweensOf(fov);
					
					// Quitar clase de activación
					if (spyglassInner) {
						spyglassInner.classList.remove("active");
					}
					
					catalejoActivo = false;
					
					// Variables para el estado inicial y final de la cámara
					const progress = Math.min(window.scrollY / cameraAnimationEnd, 1);
					const startY = 100;
					const endY = 10;
					const startZ = 0;
					const endZ = 300;
					const targetY = startY + (endY - startY) * progress;
					const targetZ = startZ + (endZ - startZ) * progress;
					
					// Timeline para una transición fluida
					const resetTimeline = gsap.timeline();
					
					// Primero restaurar el FOV mientras mantenemos la inclinación
					resetTimeline.to(fov, {
						value: 30, // Valor intermedio de FOV
						duration: 0.8,
						ease: "power2.inOut",
						onUpdate: () => {
							camera.fov = fov.value;
							camera.updateProjectionMatrix();
							// IMPORTANTE: Mantener la misma inclinación durante el reseteo del zoom
							camera.lookAt(0, 60, -9000);
						}
					});
					
					// Segundo paso: restaurar completamente el FOV y mover la cámara
					resetTimeline.to(fov, {
						value: 55,
						duration: 0.8,
						ease: "power2.inOut",
						onUpdate: () => {
							camera.fov = fov.value;
							camera.updateProjectionMatrix();
							// Transición suave del punto de mira
							const progress = 1 - (fov.value - 30) / 25; // Valor entre 0 y 1
							const lookAtY = 60 * progress; // Transición de 60 a 0
							camera.lookAt(0, lookAtY, -9000 * progress);
						}
					}, "+=0.1");
					
					// Tercer paso: restaurar completamente la posición y orientación
					resetTimeline.to(camera.position, {
						y: targetY,
						z: targetZ,
						duration: 0.8,
						ease: "power2.inOut",
						onUpdate: () => {
							// Transición final de la mirada
							const progress = (camera.position.y - 5) / (targetY - 5);
							// Transición gradual desde mirar al faro a mirar al océano
							if (progress >= 0.7) {
								camera.lookAt(0, 0, 0);
							} else {
								camera.lookAt(0, 0, -9000 * (1 - progress));
							}
						}
					}, "-=0.5");
				}

				window.addEventListener("scroll", () => {
					const scrollTop = window.scrollY;
					const scrollDirection = scrollTop > lastScrollPosition ? 'down' : 'up';
					lastScrollPosition = scrollTop;
					const progress = Math.min(scrollTop / cameraAnimationEnd, 1);

					// Camera path: from top-down to horizon view
					if (!catalejoActivo) {
						const startY = 100;
						const endY = 10;
						const startZ = 0;
						const endZ = 300;

						camera.position.y = startY + (endY - startY) * progress;
						camera.position.z = startZ + (endZ - startZ) * progress;
						camera.lookAt(0, 0, 0);
					} else {
						// Mientras el catalejo está activo, mantener la inclinación hacia el faro
						camera.lookAt(0, 60, -9000);
					}

					// Animación de los textos
					if (scrollTop >= text1Start) {
						// Asegurar que el contenedor es visible cuando empezamos con los textos
						if (textContainer && textContainer.style.opacity !== "1") {
							gsap.to(textContainer, {
								opacity: 1,
								duration: 0.3
							});
						}

						// Primer texto - aparece y permanece más tiempo
						if (oceanText1) {
							const text1Progress = (scrollTop - text1Start) / (text1End - text1Start);
							
							if (text1Progress <= 0.8) {
								// Aparecer gradualmente y subir lentamente
								const opacity = Math.min(text1Progress * 2, 1);
								const yOffset = 20 * (1 - Math.min(text1Progress * 1.5, 1));
								const scrollOffset = text1Progress > 0.2 ? (text1Progress - 0.2) * -80 : 0; // Comienza a subir después del 20% de progreso
								
								gsap.set(oceanText1, {
									opacity: opacity,
									y: yOffset + scrollOffset
								});
							} else {
								// Desaparecer más gradualmente cuando pasamos al segundo texto
								const fadeOutProgress = Math.min((text1Progress - 0.8) / 0.2, 1);
								gsap.set(oceanText1, {
									opacity: Math.max(1 - fadeOutProgress, 0),
									y: -80 * fadeOutProgress - 80 * 0.6 // Continúa subiendo mientras se desvanece
								});
							}
						}

						// Segundo texto - aparece después del primero y permanece más tiempo
						if (oceanText2) {
							if (scrollTop >= text2Start) {
								const text2Progress = (scrollTop - text2Start) / (text2End - text2Start);
								
								if (text2Progress <= 0.9) { // Permanece visible por más tiempo
									// Aparecer gradualmente y permitir más movimiento hacia arriba
									const opacity = Math.min(text2Progress * 2, 1);
									const yOffset = 20 * (1 - Math.min(text2Progress * 1.5, 1));
									const scrollOffset = text2Progress > 0.1 ? (text2Progress - 0.1) * -120 : 0; // Mayor desplazamiento vertical
									
									gsap.set(oceanText2, {
										opacity: opacity,
										y: yOffset + scrollOffset
									});
								} else {
									// Desvanecer solo al final del recorrido
									const fadeOutProgress = (text2Progress - 0.9) / 0.1;
									gsap.set(oceanText2, {
										opacity: Math.max(1 - fadeOutProgress, 0),
										y: -120 * 0.8 - fadeOutProgress * 50 // Continúa subiendo mientras se desvanece
									});
								}
							} else {
								// Asegurar que está oculto antes de su punto de aparición
								gsap.set(oceanText2, {
									opacity: 0,
									y: 20
								});
							}
						}
					} else {
						// Ocultar los textos si estamos por encima del punto de aparición
						if (textContainer) {
							gsap.to(textContainer, {
								opacity: 0,
								duration: 0.3
							});
						}
					}

					// Efecto catalejo después de los textos
					if (scrollTop >= spyglassStart) {
						// Mostrar contenedor de viñeta
						if (spyglassContainer && spyglassContainer.style.opacity !== "1") {
							gsap.to(spyglassContainer, {
								opacity: 1,
								duration: 0.3
							});
						}
						
						// Iniciar la animación automática del catalejo solo una vez
						if (!animacionIniciada) {
							animacionIniciada = true;
							iniciarAnimacionCatalejo();
						}
					} else {
						// Ocultar el catalejo cuando estamos por encima del punto de aparición
						if (spyglassContainer && spyglassContainer.style.opacity !== "0") {
							gsap.to(spyglassContainer, {
								opacity: 0,
								duration: 0.3
							});
							
							// Resetear la animación si volvemos arriba
							if (animacionIniciada) {
								animacionIniciada = false;
								resetearAnimacionCatalejo();
								}
						}
					}

					// Desvanecer texto introductorio y flecha al hacer scroll
					const fadeOutProgress = Math.min(scrollTop / (window.innerHeight * 0.3), 1);
					if (introText) {
						introText.style.opacity = String(1 - fadeOutProgress);
					}
					if (scrollIndicator) {
						scrollIndicator.style.opacity = String(1 - fadeOutProgress);
					}
				});
			});
		</script>

		<div id="scroll-space"></div>

		<section id="info-section" class="flex flex-col items-center justify-center">
			<!-- Los textos ahora están en text-container para la animación -->
		</section>
	</body>
</html>
