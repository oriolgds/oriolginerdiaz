---
import { Image } from "astro:assets";
import "../styles/global.css";
---
<!doctype html>
<html lang="es">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Oriol Giner Díaz</title>
		<style>
			body {
				margin: 0;
			}
			#container {
				width: 100vw;
				height: 100vh;
				position: fixed;
				top: 0;
				left: 0;
				z-index: 0;
			}
			canvas {
				width: 100%;
				height: 100%;
			}
			/* Space to drive fake scroll */
			#scroll-space {
				height: 120vh;
			}
			/* Section that appears after the camera animation */
			#info-section {
				min-height: 100vh;
				display: flex;
				justify-content: center;
				align-items: center;
				gap: 2rem;
				background: #ffffff;
				opacity: 0;
				transition: opacity 0.5s ease;
				position: relative;
				z-index: 10;
			}
			.card {
				width: 300px;
				padding: 1.5rem;
				border-radius: 8px;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
				background: #f8f8f8;
			}
		</style>
	</head>
	<body class="bg-black">
		<div id="container"></div>

		<!-- Texto introductorio -->
		<div class="intro-text fixed inset-0 flex flex-col items-center justify-center z-20 text-center pointer-events-none select-none">
			<h1 class="text-5xl md:text-6xl font-extrabold text-white drop-shadow-lg mb-4">Soy Oriol Giner</h1>
			<p class="text-xl md:text-2xl font-semibold text-white/90 drop-shadow mb-2 max-w-2xl">Capitán de proyectos digitales. En el vasto océano de la tecnología, guío tus ideas hacia puertos seguros con experiencia y visión.</p>
		</div>

		<!-- Indicador de scroll -->
		<div class="scroll-indicator fixed bottom-10 left-1/2 -translate-x-1/2 z-20 flex flex-col items-center pointer-events-none select-none">
			<div class="animate-bounce">
				<svg class="w-10 h-10 text-white drop-shadow-lg" fill="none" stroke="currentColor" stroke-width="4" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
				</svg>
			</div>
		</div>

		<script>
			import { gsap } from "gsap";
			import * as THREE from "three";
			import { Water } from "three/addons/objects/Water.js";
			import { Sky } from "three/addons/objects/Sky.js";

			let container;
			let camera, scene, renderer;
			let water, sun;
			// Añadir variables para las nubes
			let cloudMeshes = [];

			init();

			function init() {
				container = document.getElementById("container");

				// Renderizador
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 0.5;
				container.appendChild(renderer.domElement);

				// Escena
				scene = new THREE.Scene();

				// Cámara
				camera = new THREE.PerspectiveCamera(
					55,
					window.innerWidth / window.innerHeight,
					1,
					20000,
				);
				camera.position.set(0, 100, 0); // Vista desde arriba
				camera.lookAt(0, 0, 0);

				// Sol
				sun = new THREE.Vector3();

				// Agua
				const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
				water = new Water(waterGeometry, {
					textureWidth: 512,
					textureHeight: 512,
					waterNormals: new THREE.TextureLoader().load(
						"/waternormals.jpg",
						function (texture) {
							texture.wrapS = texture.wrapT =
								THREE.RepeatWrapping;
						},
					),
					sunDirection: new THREE.Vector3(),
					sunColor: 0xffffff,
					waterColor: 0x001e0f,
					distortionScale: 3.7,
					fog: scene.fog !== undefined,
				});
				water.rotation.x = -Math.PI / 2;
				scene.add(water);

				// Cielo
				const sky = new Sky();
				sky.scale.setScalar(10000);
				scene.add(sky);

				const skyUniforms = sky.material.uniforms;
				skyUniforms["turbidity"].value = 15; // Más partículas en el aire para amanecer
				skyUniforms["rayleigh"].value = 3;  // Azul intenso
				skyUniforms["mieCoefficient"].value = 0.02; // Más dispersión
				skyUniforms["mieDirectionalG"].value = 0.8; // Luz más direccional

				// Configuración del sol para amanecer
				const parameters = {
					elevation: 5, // Sol bajo, cerca del horizonte
					azimuth: 180, // Este
				};

				const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);
				const theta = THREE.MathUtils.degToRad(parameters.azimuth);
				sun.setFromSphericalCoords(1, phi, theta);
				sky.material.uniforms["sunPosition"].value.copy(sun);
				water.material.uniforms["sunDirection"].value.copy(sun).normalize();

				// Generador de entorno
				const pmremGenerator = new THREE.PMREMGenerator(renderer);
				const sceneEnv = new THREE.Scene();
				sceneEnv.add(sky);
				const renderTarget = pmremGenerator.fromScene(sceneEnv);
				scene.add(sky);
				scene.environment = renderTarget.texture;

				// --- NUBES ---
				const cloudTexture1 = new THREE.TextureLoader().load("/clouds/cloud1.png");
				const cloudTexture2 = new THREE.TextureLoader().load("/clouds/cloud2.png");
				const cloudTexture3 = new THREE.TextureLoader().load("/clouds/cloud3.png");

				const cloudMaterial1 = new THREE.MeshBasicMaterial({
					map: cloudTexture1,
					transparent: true,
					depthWrite: false,
					opacity: 0.7,
				});
				const cloudMaterial2 = new THREE.MeshBasicMaterial({
					map: cloudTexture2,
					transparent: true,
					depthWrite: false,
					opacity: 0.7,
				});
				const cloudMaterial3 = new THREE.MeshBasicMaterial({
					map: cloudTexture3,
					transparent: true,
					depthWrite: false,
					opacity: 0.7,
				});

				// Crear varias nubes con posiciones y tamaños variados
				const cloudConfigs = [
					{ x: -200, y: 70, z: -400, scale: 180, mat: cloudMaterial1 },
					{ x: 300, y: 110, z: -350, scale: 150, mat: cloudMaterial2 },
					{ x: 0, y: 190, z: -500, scale: 220, mat: cloudMaterial3 },
					{ x: -350, y: 100, z: -300, scale: 120, mat: cloudMaterial2 },
				];
				cloudConfigs.forEach(cfg => {
					const geometry = new THREE.PlaneGeometry(cfg.scale, cfg.scale * 0.5);
					const mesh = new THREE.Mesh(geometry, cfg.mat);
					mesh.position.set(cfg.x, cfg.y, cfg.z);
					mesh.rotation.x = 0; // Sin inclinación
					scene.add(mesh);
					cloudMeshes.push(mesh);
				});

				// Evento de cambio de tamaño
				window.addEventListener("resize", onWindowResize);

				// Iniciar animación
				animate();
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				requestAnimationFrame(animate);
				render();
			}

			function render() {
				const time = performance.now() * 0.001;
				water.material.uniforms["time"].value += 1.0 / 60.0;
				renderer.render(scene, camera);
			}

			// -------- Scroll-driven camera animation --------
			window.addEventListener("load", () => {
				const scrollSpace = document.getElementById("scroll-space");
				const infoSection = document.getElementById("info-section");
				const perspectiveScrollHeight = scrollSpace?.offsetHeight || 0;
				const introText = document.querySelector(".intro-text") as HTMLElement;
				const scrollIndicator = document.querySelector(".scroll-indicator") as HTMLElement;

				// Animación del texto introductorio con GSAP
				if (introText && scrollIndicator) {
					const timeline = gsap.timeline();
					timeline.to(introText, {
						opacity: 1,
						duration: 1,
						ease: "power2.out",
						delay: 0.5
					});
					timeline.from(introText.querySelector("h1"), {
						y: 50,
						opacity: 0,
						duration: 0.8,
						ease: "back.out"
					}, "-=0.5");
					timeline.from(introText.querySelector("p"), {
						y: 30,
						opacity: 0,
						duration: 0.8,
						ease: "power2.out"
					}, "-=0.3");
					timeline.to(scrollIndicator, {
						opacity: 1,
						duration: 0.8,
						ease: "power2.out"
					}, "-=0.2");
				}

				window.addEventListener("scroll", () => {
					const scrollTop = window.scrollY;
					const progress = Math.min(scrollTop / perspectiveScrollHeight, 1);

					// Camera path: from top-down to horizon view
					const startY = 100;
					const endY = 10;
					const startZ = 0;
					const endZ = 300;

					camera.position.y = startY + (endY - startY) * progress;
					camera.position.z = startZ + (endZ - startZ) * progress;
					camera.lookAt(0, 0, 0);

					// Reveal cards
					if (infoSection) {
						infoSection.style.opacity = progress >= 1 ? "1" : "0";
					}

					// Desvanecer texto introductorio y flecha al hacer scroll
					const fadeOutProgress = Math.min(scrollTop / (window.innerHeight * 0.3), 1);
					if (introText) {
						introText.style.opacity = String(1 - fadeOutProgress);
					}
					if (scrollIndicator) {
						scrollIndicator.style.opacity = String(1 - fadeOutProgress);
					}
				});
			});
		</script>

		<div id="scroll-space"></div>

		<section id="info-section">
			<div class="card">Card 1</div>
			<div class="card">Card 2</div>
			<div class="card">Card 3</div>
		</section>


	</body>
</html>
