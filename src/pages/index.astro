---
import { Image } from "astro:assets";
import "../styles/global.css";
---
<!doctype html>
<html lang="es">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Oriol Giner Díaz</title>
		<style>
			body {
				margin: 0;
				height: 600vh; /* Aumentado de 300vh a 500vh para permitir más scroll */
			}
			#container {
				width: 100vw;
				height: 100vh;
				position: fixed;
				top: 0;
				left: 0;
				z-index: 0;
			}
			canvas {
				width: 100%;
				height: 100%;
			}
			/* Space to drive fake scroll */
			#scroll-space {
				height: 120vh;
			}
			/* Section that appears after the camera animation */
			#info-section {
				min-height: 100vh;
				display: flex;
				justify-content: center;
				align-items: center;
				flex-direction: column;
				gap: 2rem;
				position: relative;
				z-index: 10;
			}
			.card {
				width: 300px;
				padding: 1.5rem;
				border-radius: 8px;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
				background: #f8f8f8;
			}
			.ocean-text {
				position: absolute;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);
				font-size: clamp(1.5rem, 4vw, 2.5rem);
				font-weight: 700;
				max-width: 800px;
				text-align: center;
				color: #ffffff;
				opacity: 0;
				text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8), 0 0 30px rgba(0, 0, 0, 0.6);
				padding: 1.5rem;
				width: 90%;
				background-color: rgba(0, 0, 0, 0.25);
				backdrop-filter: blur(4px);
				border-radius: 12px;
				box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
				border: 1px solid rgba(255, 255, 255, 0.1);
			}
			.text-container {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100vh;
				z-index: 5;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				pointer-events: none;
			}
		</style>
	</head>
	<body class="bg-black">
		<div id="container"></div>

		<!-- Texto introductorio -->
		<div class="intro-text fixed inset-0 flex flex-col items-center justify-center z-20 text-center pointer-events-none select-none">
			<h1 class="text-5xl md:text-6xl font-extrabold text-white drop-shadow-lg mb-4">Soy Oriol Giner</h1>
			<p class="text-xl md:text-2xl font-semibold text-white/90 drop-shadow mb-2 max-w-2xl">
				Un desarrollador de software versatil.
				<br>
				En el vasto océano de la tecnología, guío tus ideas hacia puertos seguros con experiencia y visión.</p>
		</div>

		<!-- Indicador de scroll -->
		<div class="scroll-indicator fixed bottom-10 left-1/2 -translate-x-1/2 z-20 flex flex-col items-center pointer-events-none select-none">
			<div class="animate-bounce">
				<svg class="w-10 h-10 text-white drop-shadow-lg" fill="none" stroke="currentColor" stroke-width="4" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
				</svg>
			</div>
		</div>

		<!-- Textos secuenciales sobre el océano -->
		<div class="text-container">
			<p class="ocean-text ocean-text-1">Muchas veces, en las inmensidades del océano es fácil perderse.</p>
			<p class="ocean-text ocean-text-2">Explora mi trabajo y empecemos a navegar juntos.</p>
		</div>

		<script>
			import { gsap } from "gsap";
			import { ScrollTrigger } from "gsap/ScrollTrigger";
			gsap.registerPlugin(ScrollTrigger);
			// ScrollSmoother import eliminado; sustituido por ScrollTrigger
			import * as THREE from "three";
			import { Water } from "three/addons/objects/Water.js";
			import { Sky } from "three/addons/objects/Sky.js";
			var container;
			var camera, scene, renderer;
			var water, sun;
			var cloudMeshes = [];
			var cloudConfigs = [];

			init();

			function init() {
				container = document.getElementById("container");

				// Renderizador
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 0.5;
				container.appendChild(renderer.domElement);

				// Escena
				scene = new THREE.Scene();

				// Cámara
				camera = new THREE.PerspectiveCamera(
					55,
					window.innerWidth / window.innerHeight,
					1,
					20000,
				);
				camera.position.set(0, 100, 0); // Vista desde arriba
				camera.lookAt(0, 0, 0);

				// Sol
				sun = new THREE.Vector3();

				// Agua
				const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
				water = new Water(waterGeometry, {
					textureWidth: 512,
					textureHeight: 512,
					waterNormals: new THREE.TextureLoader().load(
						"/waternormals.jpg",
						function (texture) {
							texture.wrapS = texture.wrapT =
								THREE.RepeatWrapping;
						},
					),
					sunDirection: new THREE.Vector3(),
					sunColor: 0xffffff,
					waterColor: 0x001e0f,
					distortionScale: 3.7,
					fog: scene.fog !== undefined,
				});
				water.rotation.x = -Math.PI / 2;
				scene.add(water);

				// Cielo
				const sky = new Sky();
				sky.scale.setScalar(10000);
				scene.add(sky);

				const skyUniforms = sky.material.uniforms;
				skyUniforms["turbidity"].value = 15; // Más partículas en el aire para amanecer
				skyUniforms["rayleigh"].value = 3;  // Azul intenso
				skyUniforms["mieCoefficient"].value = 0.02; // Más dispersión
				skyUniforms["mieDirectionalG"].value = 0.8; // Luz más direccional

				// Configuración del sol para amanecer
				const parameters = {
					elevation: 5, // Sol bajo, cerca del horizonte
					azimuth: 180, // Este
				};

				const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);
				const theta = THREE.MathUtils.degToRad(parameters.azimuth);
				sun.setFromSphericalCoords(1, phi, theta);
				sky.material.uniforms["sunPosition"].value.copy(sun);
				water.material.uniforms["sunDirection"].value.copy(sun).normalize();

				// Generador de entorno
				const pmremGenerator = new THREE.PMREMGenerator(renderer);
				const sceneEnv = new THREE.Scene();
				sceneEnv.add(sky);
				const renderTarget = pmremGenerator.fromScene(sceneEnv);
				scene.add(sky);
				scene.environment = renderTarget.texture;

				// --- NUBES ---
				const cloudTexture1 = new THREE.TextureLoader().load("/clouds/cloud1.png");
				const cloudTexture2 = new THREE.TextureLoader().load("/clouds/cloud2.png");
				const cloudTexture3 = new THREE.TextureLoader().load("/clouds/cloud3.png");

				const cloudMaterial1 = new THREE.MeshBasicMaterial({
					map: cloudTexture1,
					transparent: true,
					depthWrite: false,
					opacity: 0.7,
				});
				const cloudMaterial2 = new THREE.MeshBasicMaterial({
					map: cloudTexture2,
					transparent: true,
					depthWrite: false,
					opacity: 0.7,
				});
				const cloudMaterial3 = new THREE.MeshBasicMaterial({
					map: cloudTexture3,
					transparent: true,
					depthWrite: false,
					opacity: 0.7,
				});

				// Crear varias nubes con posiciones y tamaños variados
				cloudConfigs = [
					{ x: -200, y: 70, z: -400, scale: 180, mat: cloudMaterial1 },
					{ x: 300, y: 110, z: -350, scale: 150, mat: cloudMaterial2 },
					{ x: 0, y: 190, z: -500, scale: 220, mat: cloudMaterial3 },
					{ x: -350, y: 100, z: -300, scale: 120, mat: cloudMaterial2 },
				];
				cloudConfigs.forEach(cfg => {
					const geometry = new THREE.PlaneGeometry(cfg.scale, cfg.scale * 0.5);
					const mesh = new THREE.Mesh(geometry, cfg.mat);
					mesh.position.set(cfg.x, cfg.y, cfg.z);
					mesh.rotation.x = 0; // Sin inclinación
					scene.add(mesh);
					cloudMeshes.push(mesh);
				});

				// Evento de cambio de tamaño
				window.addEventListener("resize", onWindowResize);

				// Iniciar animación
				animate();
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				requestAnimationFrame(animate);
				render();
			}

			function render() {
				const time = performance.now() * 0.001;
				water.material.uniforms["time"].value += 1.0 / 60.0;

				// Movimiento horizontal lento de las nubes
				cloudMeshes.forEach((mesh, i) => {
					const baseX = cloudConfigs[i].x;
					const speed = 5 + i * 2; // Velocidad diferente para cada nube
					mesh.position.x = baseX + Math.sin(time / speed + i) * 40; // Oscilación suave
				});

				renderer.render(scene, camera);
			}

			// -------- Scroll-driven camera animation --------
			window.addEventListener("load", () => {
				const scrollSpace = document.getElementById("scroll-space");
				const introText = document.querySelector(".intro-text") as HTMLElement;
				const oceanTexts = document.querySelectorAll(".ocean-text");
				const scrollIndicator = document.querySelector(".scroll-indicator") as HTMLElement;
				const textContainer = document.querySelector(".text-container") as HTMLElement;
				const oceanText1 = document.querySelector(".ocean-text-1") as HTMLElement;
				const oceanText2 = document.querySelector(".ocean-text-2") as HTMLElement;
				
				// Calcular puntos de referencia para el scroll
				const totalScrollHeight = document.body.scrollHeight - window.innerHeight;
				const cameraAnimationEnd = window.innerHeight * 1.2; // Altura del scroll-space
				const text1Start = cameraAnimationEnd;
				const text1End = cameraAnimationEnd + window.innerHeight * 1.2; // Aumentado para más duración
				const text2Start = text1End - window.innerHeight * 0.3; // Superposición para transición suave
				const text2End = text2Start + window.innerHeight * 2; // Aumentado significativamente para más duración

				// Animación del texto introductorio con GSAP
				if (introText && scrollIndicator) {
					const timeline = gsap.timeline();
					timeline.to(introText, {
						opacity: 1,
						duration: 1,
						ease: "power2.out",
						delay: 0.5
					});
					timeline.from(introText.querySelector("h1"), {
						y: 50,
						opacity: 0,
						duration: 0.8,
						ease: "back.out"
					}, "-=0.5");
					timeline.from(introText.querySelector("p"), {
						y: 30,
						opacity: 0,
						duration: 0.8,
						ease: "power2.out"
					}, "-=0.3");
					timeline.to(scrollIndicator, {
						opacity: 1,
						duration: 0.8,
						ease: "power2.out"
					}, "-=0.2");
				}

				window.addEventListener("scroll", () => {
					const scrollTop = window.scrollY;
					const progress = Math.min(scrollTop / cameraAnimationEnd, 1);

					// Camera path: from top-down to horizon view
					const startY = 100;
					const endY = 10;
					const startZ = 0;
					const endZ = 300;

					camera.position.y = startY + (endY - startY) * progress;
					camera.position.z = startZ + (endZ - startZ) * progress;
					camera.lookAt(0, 0, 0);

					// Animación de los textos
					if (scrollTop >= text1Start) {
						// Asegurar que el contenedor es visible cuando empezamos con los textos
						if (textContainer && textContainer.style.opacity !== "1") {
							gsap.to(textContainer, {
								opacity: 1,
								duration: 0.3
							});
						}

						// Primer texto - aparece y permanece más tiempo
						if (oceanText1) {
							const text1Progress = (scrollTop - text1Start) / (text1End - text1Start);
							
							if (text1Progress <= 0.8) {
								// Aparecer gradualmente y subir lentamente
								const opacity = Math.min(text1Progress * 2, 1);
								const yOffset = 20 * (1 - Math.min(text1Progress * 1.5, 1));
								const scrollOffset = text1Progress > 0.2 ? (text1Progress - 0.2) * -80 : 0; // Comienza a subir después del 20% de progreso
								
								gsap.set(oceanText1, {
									opacity: opacity,
									y: yOffset + scrollOffset
								});
							} else {
								// Desaparecer más gradualmente cuando pasamos al segundo texto
								const fadeOutProgress = Math.min((text1Progress - 0.8) / 0.2, 1);
								gsap.set(oceanText1, {
									opacity: Math.max(1 - fadeOutProgress, 0),
									y: -80 * fadeOutProgress - 80 * 0.6 // Continúa subiendo mientras se desvanece
								});
							}
						}

						// Segundo texto - aparece después del primero y permanece más tiempo
						if (oceanText2) {
							if (scrollTop >= text2Start) {
								const text2Progress = (scrollTop - text2Start) / (text2End - text2Start);
								
								if (text2Progress <= 0.9) { // Permanece visible por más tiempo
									// Aparecer gradualmente y permitir más movimiento hacia arriba
									const opacity = Math.min(text2Progress * 2, 1);
									const yOffset = 20 * (1 - Math.min(text2Progress * 1.5, 1));
									const scrollOffset = text2Progress > 0.1 ? (text2Progress - 0.1) * -120 : 0; // Mayor desplazamiento vertical
									
									gsap.set(oceanText2, {
										opacity: opacity,
										y: yOffset + scrollOffset
									});
								} else {
									// Desvanecer solo al final del recorrido
									const fadeOutProgress = (text2Progress - 0.9) / 0.1;
									gsap.set(oceanText2, {
										opacity: Math.max(1 - fadeOutProgress, 0),
										y: -120 * 0.8 - fadeOutProgress * 50 // Continúa subiendo mientras se desvanece
									});
								}
							} else {
								// Asegurar que está oculto antes de su punto de aparición
								gsap.set(oceanText2, {
									opacity: 0,
									y: 20
								});
							}
						}
					} else {
						// Ocultar los textos si estamos por encima del punto de aparición
						if (textContainer) {
							gsap.to(textContainer, {
								opacity: 0,
								duration: 0.3
							});
						}
					}

					// Desvanecer texto introductorio y flecha al hacer scroll
					const fadeOutProgress = Math.min(scrollTop / (window.innerHeight * 0.3), 1);
					if (introText) {
						introText.style.opacity = String(1 - fadeOutProgress);
					}
					if (scrollIndicator) {
						scrollIndicator.style.opacity = String(1 - fadeOutProgress);
					}
				});
			});
		</script>

		<div id="scroll-space"></div>

		<section id="info-section" class="flex flex-col items-center justify-center">
			<!-- Los textos ahora están en text-container para la animación -->
		</section>
	</body>
</html>
